<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Hugging Face Posts</title><link>https://huggingface.co/</link><description>This is a website scraping RSS feed for the Hugginface trending posts.</description><generator>rfeed v1.1.1</generator><docs>https://github.com/svpino/rfeed/blob/master/README.md</docs><item><title>Do you remember</title><link>https://huggingface.co/posts/jasoncorkill/614528339803376</link><description>Do you remember https://thispersondoesnotexist.com/ ? It was one of the first cases where the future of generative media really hit us. Humans are incredibly good at recognizing and analyzing faces, so they are a very good litmus test for any generative image model. But none of the current benchmarks measure the ability of models to generate humans independently. So we built our own. We measure the models ability to generate a diverse set of human faces and using over 20'000 human annotations we ranked all of the major models on their ability to generate faces. Find the full ranking here: https://app.rapidata.ai/mri/benchmarks/68af24ae74482280b62f7596 We have release the full underlying data publicly here on huggingface: Rapidata/Face_Generation_Benchmark See translation</description><pubDate>Wed, 12 Nov 2025 09:26:36 GMT</pubDate><guid isPermaLink="true">https://huggingface.co/posts/jasoncorkill/614528339803376</guid></item><item><title>How to Use the AI Image Generator</title><link>https://huggingface.co/posts/wang12390/272731401856149</link><description>How to Use the AI Image Generator https://miragic.ai/products/image-generator 1. Describe Your Vision: Enter a text prompt describing what you want to create. Example: "A futuristic city skyline at sunset with glowing airships." 2. Select a Style: Choose an art styleâ€”Realistic, Anime, Painterly, Surreal, or Minimalistâ€”to match your idea. 3. Generate and Refine: Click "Generate Image" and let the AI do its magic. Want to tweak it? Refine your prompt or try a new style. 4. Download and Share: Save your creation in high resolution or share it directly on social media. See translation</description><pubDate>Wed, 12 Nov 2025 09:26:36 GMT</pubDate><guid isPermaLink="true">https://huggingface.co/posts/wang12390/272731401856149</guid></item><item><title>ğŸš€ AutoXLA - Accelerating Large Models on TPU</title><link>https://huggingface.co/posts/Locutusque/780653085928819</link><description>ğŸš€ AutoXLA - Accelerating Large Models on TPU AutoXLA is an experimental library that automates the distribution, optimization, and quantization of large language models for TPUs using PyTorch/XLA. It extends the Hugging Face Transformers interface with TPU-aware features such as automatic sharding, custom attention kernels, and quantization-aware loading, making large-scale deployment and training both simpler and faster. With quantization and Splash Attention kernels, AutoXLA achieves up to 4Ã— speedups over standard Flash Attention implementations, significantly improving throughput for both inference and training workloads. Whether youâ€™re experimenting with distributed setups (FSDP, 2D, or 3D sharding) or optimizing memory via LanguageModelQuantizer, AutoXLA is built to make scaling LLMs on TPU seamless. âš ï¸ Note: This is an experimental repository. Expect rough edges! Please report bugs or unexpected behavior through GitHub issues. ğŸ”— GitHub Repository:...</description><pubDate>Wed, 12 Nov 2025 09:26:36 GMT</pubDate><guid isPermaLink="true">https://huggingface.co/posts/Locutusque/780653085928819</guid></item><item><title>Garment Try-On: Transforming Fashion Design and Shopping with AI</title><link>https://huggingface.co/posts/wang12390/363647142063020</link><description>Garment Try-On: Transforming Fashion Design and Shopping with AI Discover how AI-powered Garment Try-On technology transforms fashion design, e-commerce, and sustainability with realistic 3D garment visualization. Miragic-AI/Miragic-Virtual-Try-On See translation</description><pubDate>Wed, 12 Nov 2025 09:26:36 GMT</pubDate><guid isPermaLink="true">https://huggingface.co/posts/wang12390/363647142063020</guid></item><item><title>Want to experiment with pre-training dataset mixtures but don't want to process terabytes of data? We've got you covered.</title><link>https://huggingface.co/posts/codelion/147786491495276</link><description>Want to experiment with pre-training dataset mixtures but don't want to process terabytes of data? We've got you covered. We're releasing a collection of several carefully curated 1B token dataset samples specifically designed for rapid prototyping and pretraining experiments: https://huggingface.co/collections/codelion/pre-training-dataset-samples These samples were created using reservoir sampling - an algorithm that guarantees statistically unbiased random samples from massive source datasets. This means results you get at the 1B token scale are representative of how these datasets behave at 100B+ token scales, letting you iterate quickly without the computational overhead. The collection includes: - finePDFs-1B: High-quality textbook-style educational content - DCLM-baseline-1B: Filtered, diverse web content - FineWeb-Edu-1B: Curated educational web resources We used these exact samples to run 50+ systematic experiments on dataset mixing strategies, ultimately discovering that a...</description><pubDate>Wed, 12 Nov 2025 09:26:36 GMT</pubDate><guid isPermaLink="true">https://huggingface.co/posts/codelion/147786491495276</guid></item><item><title>7+ Main precision formats used in AI:</title><link>https://huggingface.co/posts/Kseniase/707388483660581</link><description>7+ Main precision formats used in AI: Precision is very important in AI as it shapes how accurate and efficient models are. It controls how finely numbers are represented, approximating real-world values with formats like fixed-point and floating-point. A recent BF16 â†’ FP16 study renewed attention to precision impact. Here are the main precision types used in AI, from full precision for training to ultra-low precision for inference: 1. FP32 (Float32): Standard full-precision float used in most training: 1 sign bit, 8 exponent bits, 23 mantissa bits. Default for backward-compatible training and baseline numerical stability 2. FP16 (Float16) â†’ https://arxiv.org/abs/2305.10947v6 Half-precision float. It balances accuracy and efficiency. 1 sign bit, 5 exponent bits, 10 mantissa bits. Common on NVIDIA Tensor Cores and mixed-precision setups. Thereâ€™s now a new wave of using it in reinforcement learning: https://www.turingpost.com/p/fp16 3. BF16 (BFloat16) â†’...</description><pubDate>Wed, 12 Nov 2025 09:26:36 GMT</pubDate><guid isPermaLink="true">https://huggingface.co/posts/Kseniase/707388483660581</guid></item><item><title>Instead of architectural upgade, each major model drop nowadays perfects a regional innovation. What Kimi brought to spot light this time is quantization aware training (QAT). I wrote an article to explain it and why it matters to reasoning models.</title><link>https://huggingface.co/posts/onekq/821878778302944</link><description>Instead of architectural upgade, each major model drop nowadays perfects a regional innovation. What Kimi brought to spot light this time is quantization aware training (QAT). I wrote an article to explain it and why it matters to reasoning models. https://huggingface.co/blog/onekq/qat-bonsai If you are interested in this kind of posts, I will introduce the Muon optimizers, another technology behind Kimi success. See translation</description><pubDate>Wed, 12 Nov 2025 09:26:36 GMT</pubDate><guid isPermaLink="true">https://huggingface.co/posts/onekq/821878778302944</guid></item><item><title>I just threw Qwen3-0.6B in BF16 into an on device AI drag race on AMD Strix Halo with vLLM:</title><link>https://huggingface.co/posts/mitkox/956503968449347</link><description>I just threw Qwen3-0.6B in BF16 into an on device AI drag race on AMD Strix Halo with vLLM: 564 tokens/sec on short 100-token sprints 96 tokens/sec on 8K-token marathons TL;DR You don't just run AI on AMD. You negotiate with it. The hardware absolutely delivers. Spoiler alert; there is exactly ONE configuration where vLLM + ROCm + Triton + PyTorch + Drivers + Ubuntu Kernel to work at the same time. Finding it required the patience of a saint Consumer AMD for AI inference is the ultimate "budget warrior" play, insane performance-per-euro, but you need hardcore technical skills that would make a senior sysadmin nod in quiet respect. See translation</description><pubDate>Wed, 12 Nov 2025 09:26:36 GMT</pubDate><guid isPermaLink="true">https://huggingface.co/posts/mitkox/956503968449347</guid></item><item><title>SparkEmbedding - SoTA cross lingual retrieval</title><link>https://huggingface.co/posts/Parveshiiii/257570757344007</link><description>SparkEmbedding - SoTA cross lingual retrieval Iam very happy to announce our latest embedding model sparkembedding-300m base on embeddinggemma-300m we fine tuned it on 1m extra examples spanning over 119 languages and result is this model achieves exceptional cross lingual retrieval Model: XenArcAI/SparkEmbedding-300m See translation</description><pubDate>Wed, 12 Nov 2025 09:26:36 GMT</pubDate><guid isPermaLink="true">https://huggingface.co/posts/Parveshiiii/257570757344007</guid></item><item><title>After training ğ’ğ¦ğ¨ğ¥ğ‹ğŒğŸ‘ on ğŸ‘ğŸ–ğŸ’ ğ‡ğŸğŸğŸğ¬ for nearly a month, I've come to realize something most people overlook: ğ¢ğ§ğŸğ«ğšğ¬ğ­ğ«ğ®ğœğ­ğ®ğ«ğ ğ¢ğ¬ ğ­ğ¡ğ ğ¦ğšğ¤ğ-ğ¨ğ«-ğ›ğ«ğğšğ¤ ğŸğšğœğ­ğ¨ğ« ğ¢ğ§ ğ‹ğ‹ğŒ ğ­ğ«ğšğ¢ğ§ğ¢ğ§ğ . ğŸ”¥</title><link>https://huggingface.co/posts/nouamanetazi/972464132222376</link><description>After training ğ’ğ¦ğ¨ğ¥ğ‹ğŒğŸ‘ on ğŸ‘ğŸ–ğŸ’ ğ‡ğŸğŸğŸğ¬ for nearly a month, I've come to realize something most people overlook: ğ¢ğ§ğŸğ«ğšğ¬ğ­ğ«ğ®ğœğ­ğ®ğ«ğ ğ¢ğ¬ ğ­ğ¡ğ ğ¦ğšğ¤ğ-ğ¨ğ«-ğ›ğ«ğğšğ¤ ğŸğšğœğ­ğ¨ğ« ğ¢ğ§ ğ‹ğ‹ğŒ ğ­ğ«ğšğ¢ğ§ğ¢ğ§ğ . ğŸ”¥ Everyone talks about model architecture and data quality. And yes, those matter immensely. But here's what nobody tells you: when your training run fails at 2 AM because of mysterious ğğ‚ğ‚ğ‹ ğğ«ğ«ğ¨ğ«ğ¬, or when your expensive GPU cluster is running at ğŸ”ğŸ% ğğŸğŸğ¢ğœğ¢ğğ§ğœğ², the problem isn't your model. It's most probably a ğ¦ğ¢ğ¬ğ®ğ¬ğ ğ¨ğŸ ğ­ğ¡ğ ğ¡ğšğ«ğğ°ğšğ«ğ. ğŸ› ï¸ Questions that seemed simple but had no clear answers: Why is ğŒğ¨ğ„ ğ­ğ«ğšğ¢ğ§ğ¢ğ§ğ  ğ¬ğ¥ğ¨ğ°ğğ« ğ­ğ¡ğšğ§ ğğğ§ğ¬ğ ğ¦ğ¨ğğğ¥ğ¬? Which ğğ‚ğ‚ğ‹ ğŸğ¥ğšğ ğ¬ should we actually set? How often should we checkpoint without killing throughput? That's why we built ğ“ğ¡ğ ğ’ğ¦ğ¨ğ¥ ğ“ğ«ğšğ¢ğ§ğ¢ğ§ğ  ğğ¥ğšğ²ğ›ğ¨ğ¨ğ¤ ğŸ“–: a complete guide covering everything from model architecture and data curation to the SmolLM3 training marathon, post-training techniques, and crucially, the ğ¢ğ§ğŸğ«ğšğ¬ğ­ğ«ğ®ğœğ­ğ®ğ«ğ ğ¥ğšğ²ğğ« that most teams get wrong. We validated real vs...</description><pubDate>Wed, 12 Nov 2025 09:26:36 GMT</pubDate><guid isPermaLink="true">https://huggingface.co/posts/nouamanetazi/972464132222376</guid></item></channel></rss>